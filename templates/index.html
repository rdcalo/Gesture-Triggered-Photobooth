<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PhotoBooth Web</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        h1 {
            color: white;
            margin-bottom: 30px;
            font-size: 3em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 50px rgba(0,0,0,0.3);
            max-width: 1000px;
            width: 100%;
        }

        #videoContainer {
            position: relative;
            width: 100%;
            background: #000;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        #video, #processedFrame {
            width: 100%;
            height: auto;
            display: block;
        }

        #processedFrame {
            display: none;
        }

        .status {
            background: #f0f0f0;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .status-text {
            font-size: 1.5em;
            color: #333;
            margin-bottom: 10px;
        }

        .gesture-info {
            font-size: 1.2em;
            color: #666;
        }

        .countdown {
            font-size: 5em;
            color: #ff4444;
            font-weight: bold;
            text-align: center;
            margin: 20px 0;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #ddd;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.2s;
        }

        #canvas {
            display: none;
        }

        .photos-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .photo-item {
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: transform 0.2s;
        }

        .photo-item:hover {
            transform: scale(1.05);
        }

        .photo-item img {
            width: 100%;
            height: auto;
            display: block;
        }

        .performance-info {
            font-size: 0.9em;
            color: #999;
            margin-top: 10px;
        }

        .fps-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .fps-good { background-color: #4CAF50; }
        .fps-ok { background-color: #FFC107; }
        .fps-bad { background-color: #F44336; }

        .quality-badge {
            display: inline-block;
            background: #4CAF50;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.8em;
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <h1>üì∏ PhotoBooth Web <span class="quality-badge">HD Quality</span></h1>
    
    <div class="container">
        <div id="videoContainer">
            <video id="video" autoplay playsinline></video>
            <img id="processedFrame" alt="Processed frame">
        </div>

        <div class="status">
            <div class="status-text" id="statusText">Starting...</div>
            <div class="gesture-info" id="gestureInfo">No gesture detected</div>
            <div id="progressContainer" style="display: none;">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
            <div class="countdown" id="countdown" style="display: none;"></div>
            <div class="performance-info" id="performanceInfo">FPS: --</div>
        </div>

        <div id="photosSection" style="display: none;">
            <h2>Captured Photos üì∏</h2>
            <div class="photos-grid" id="photosGrid"></div>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const socket = io();
        const video = document.getElementById('video');
        const processedFrame = document.getElementById('processedFrame');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const statusText = document.getElementById('statusText');
        const gestureInfo = document.getElementById('gestureInfo');
        const countdown = document.getElementById('countdown');
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const photosGrid = document.getElementById('photosGrid');
        const photosSection = document.getElementById('photosSection');
        const performanceInfo = document.getElementById('performanceInfo');

        let canSend = true;
        let capturedPhotos = [];
        let frameCount = 0;
        let lastFpsUpdate = Date.now();
        let currentState = 'PROMPT_TIMER';
        let processingTimeout = null;
        let lastFrameTime = 0;

        // Performance settings - MAXIMUM OPTIMIZATION
        const SCALE_FACTOR = 0.35;     // Very small for detection (448x252)
        const JPEG_QUALITY = 0.5;      // Low quality for speed
        const FRAME_INTERVAL = 200;    // Target 5 FPS
        const RESPONSE_TIMEOUT = 2000; // Force reset if no response in 2s

        // Access webcam - Request HD quality for captures
        navigator.mediaDevices.getUserMedia({ 
            video: { 
                width: { ideal: 1920 },  // Request 1080p if available
                height: { ideal: 1080 },
                facingMode: 'user'
            } 
        })
        .then(stream => {
            video.srcObject = stream;
            video.onloadedmetadata = () => {
                // Set canvas to reduced resolution for gesture detection
                canvas.width = video.videoWidth * SCALE_FACTOR;
                canvas.height = video.videoHeight * SCALE_FACTOR;
                
                console.log(`üìπ Video Resolution: ${video.videoWidth}x${video.videoHeight}`);
                console.log(`üîç Detection Resolution: ${canvas.width}x${canvas.height}`);
                
                startSending();
            };
        })
        .catch(err => {
            console.error('Error accessing camera:', err);
            statusText.textContent = 'Error: Cannot access camera';
        });

        // Send frames to server - OPTIMIZED WITH TIMEOUT PROTECTION
        function startSending() {
            setInterval(() => {
                const now = Date.now();
                
                // Enforce minimum time between frames
                if (now - lastFrameTime < FRAME_INTERVAL) {
                    return;
                }
                
                // Allow sending during all states (including countdown for updates)
                if (canSend) {
                    canSend = false;
                    lastFrameTime = now;
                    
                    // Clear any existing timeout
                    if (processingTimeout) {
                        clearTimeout(processingTimeout);
                    }
                    
                    // Set timeout to force reset if backend doesn't respond
                    processingTimeout = setTimeout(() => {
                        console.warn('‚ö†Ô∏è Backend timeout, forcing reset');
                        canSend = true;
                    }, RESPONSE_TIMEOUT);
                    
                    // Draw downscaled image for gesture detection
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    // Convert to JPEG with lower quality for speed
                    const imageData = canvas.toDataURL('image/jpeg', JPEG_QUALITY);
                    
                    socket.emit('video_frame', { image: imageData });
                    
                    // Update FPS counter
                    updateFPS();
                }
            }, 50); // Check every 50ms, but enforce FRAME_INTERVAL
        }

        // Update FPS display
        function updateFPS() {
            frameCount++;
            const now = Date.now();
            const elapsed = now - lastFpsUpdate;
            
            if (elapsed >= 1000) {
                const fps = Math.round((frameCount / elapsed) * 1000);
                
                // Determine FPS quality indicator
                let indicator = '';
                if (fps >= 4) {
                    indicator = '<span class="fps-indicator fps-good"></span>';
                } else if (fps >= 2) {
                    indicator = '<span class="fps-indicator fps-ok"></span>';
                } else {
                    indicator = '<span class="fps-indicator fps-bad"></span>';
                }
                
                performanceInfo.innerHTML = `${indicator}FPS: ${fps} | Detection: ${canvas.width}x${canvas.height} | Capture: ${video.videoWidth}x${video.videoHeight}`;
                frameCount = 0;
                lastFpsUpdate = now;
            }
        }

        // Receive state updates
        socket.on('state_update', (data) => {
            // Clear timeout since we got a response
            if (processingTimeout) {
                clearTimeout(processingTimeout);
                processingTimeout = null;
            }
            
            canSend = true; // Allow next frame to be sent
            currentState = data.state; // Track current state
            
            // DEBUG: Log state changes
            if (data.state === 'CAPTURE_DONE') {
                console.log('üéØ State is CAPTURE_DONE, trigger_capture:', data.trigger_capture);
            }
            
            // Check if we should trigger photo capture
            if (data.trigger_capture === true) {
                console.log('üì∏ Capture triggered by state update');
                capturePhoto();
            }
            
            // Free up memory by releasing old frame
            if (processedFrame.src && processedFrame.src.startsWith('data:')) {
                // Only revoke blob URLs, not data URLs
            }
            
            // Show processed frame (only when not in countdown for performance)
            if (currentState !== 'COUNTDOWN') {
                processedFrame.src = data.frame;
                processedFrame.style.display = 'block';
                video.style.display = 'none';
            } else {
                // During countdown, show raw video for smoother experience
                processedFrame.style.display = 'none';
                video.style.display = 'block';
            }
            
            // Update gesture info
            if (data.gesture) {
                gestureInfo.textContent = `Detected: ${data.gesture}`;
            } else {
                gestureInfo.textContent = 'No gesture detected';
            }
            
            // Update status based on state
            updateStatus(data);
        });

        function updateStatus(data) {
            const { state, timer_value, countdown: countdownValue, streak_progress } = data;
            
            countdown.style.display = 'none';
            progressContainer.style.display = 'none';
            
            switch(state) {
                case 'PROMPT_TIMER':
                    statusText.textContent = 'Welcome to PhotoBooth!';
                    statusText.innerHTML += '<br><small>Show 1-5 fingers to set your timer</small>';
                    break;
                    
                case 'DETECTING_FINGERS':
                    statusText.textContent = 'Hold steady...';
                    if (streak_progress) {
                        progressContainer.style.display = 'block';
                        const percent = (streak_progress.current / streak_progress.required) * 100;
                        progressFill.style.width = percent + '%';
                    }
                    break;
                    
                case 'TIMER_SET':
                case 'AWAIT_THUMBS_UP':
                    statusText.textContent = `Timer set to ${timer_value} seconds!`;
                    statusText.innerHTML += '<br><small>üëç Thumbs up to START | üëä Fist to CHANGE</small>';
                    if (streak_progress) {
                        progressContainer.style.display = 'block';
                        const percent = (streak_progress.current / streak_progress.required) * 100;
                        progressFill.style.width = percent + '%';
                    }
                    break;
                    
                case 'COUNTDOWN':
                    countdown.style.display = 'block';
                    if (countdownValue !== null && countdownValue !== undefined) {
                        countdown.textContent = countdownValue > 0 ? countdownValue : 'üì∏ Say Cheese!';
                        console.log(`‚è± Countdown: ${countdownValue}`);
                    }
                    statusText.textContent = 'Get ready!';
                    break;
                    
                case 'CAPTURE_DONE':
                    statusText.textContent = 'Photo captured! üéâ';
                    break;
            }
        }

        // Capture photo function - FULL HD QUALITY
        function capturePhoto() {
            console.log('üì∏ Capture photo function called');
            console.log('üìπ Video dimensions:', video.videoWidth, 'x', video.videoHeight);
            
            // Create a full-resolution capture canvas
            const captureCanvas = document.createElement('canvas');
            captureCanvas.width = video.videoWidth;   // Full HD resolution
            captureCanvas.height = video.videoHeight;
            const captureCtx = captureCanvas.getContext('2d');
            
            // Draw at full resolution
            captureCtx.drawImage(video, 0, 0, captureCanvas.width, captureCanvas.height);
            
            // Save as high-quality PNG (lossless)
            const imageData = captureCanvas.toDataURL('image/png');
            
            console.log(`‚úÖ Image captured at ${captureCanvas.width}x${captureCanvas.height}`);
            console.log(`üì¶ Image data size: ${(imageData.length / 1024).toFixed(2)} KB`);
            
            socket.emit('save_photo', { image: imageData });
            console.log('üì§ Sent photo to server for saving');
        }

        // Legacy capture photo event listener (backup)
        socket.on('capture_photo', () => {
            console.log('üì∏ Capture photo event received (legacy)');
            capturePhoto();
        });

        // Photo saved event
        socket.on('photo_saved', (data) => {
            console.log('‚úÖ Photo saved successfully:', data.filename);
            capturedPhotos.push(data.filename);
            displayPhotos();
            
            // Show success message briefly
            statusText.innerHTML = 'üéâ Photo saved!<br><small>Show fingers to take another</small>';
        });

        function displayPhotos() {
            if (capturedPhotos.length > 0) {
                photosSection.style.display = 'block';
                photosGrid.innerHTML = '';
                capturedPhotos.forEach(filename => {
                    const div = document.createElement('div');
                    div.className = 'photo-item';
                    div.innerHTML = `<img src="/${filename}" alt="Captured photo">`;
                    div.onclick = () => window.open(`/${filename}`, '_blank');
                    photosGrid.appendChild(div);
                });
            }
        }

        socket.on('connected', (data) => {
            console.log('‚úÖ Connected to server. Session:', data.session);
        });
    </script>
</body>
</html>